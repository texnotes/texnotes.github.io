## Портфолио ##
Задание недельное, но я заберу слепок задания состоянием на утро субботы (02.22, 8 00)

Реализовать страницу, с раскладкой подобной расскладке в файле sketch.jpg. Слева - список домашних названий (названя должны быть звучными, а не 04. functions-methods, например). Справа - несколько табов.

Расскладка должна генерироваться динамически. Новые задания должны добавляться легко, без необходимости правок многих файлов.

При клике по заданию в правой колонке отображаются табы, соответствующие этому заданию. Выбранным может быть только 1 задание. Обязательный таб - "описание".

В этом табе содержится текст описания, требования к заданию. Описание должно хранится на диске в виде markdow текста (http://daringfireball.net/projects/markdown/), и отображаться на странице в виде html разметки. (для этого нужно найти библиотеку преобразующую markdown в html в браузере).

Рядом с табом описания размещены табы по количеству исходных файлов в задании. Название файла совпадает с названием файла. В этих табах размещен исходный текст файлов, подсвеченный с помощью highlightjs http://highlightjs.org

Так как с помощью js нельзя узнать о файлах, находящихся на диске, но можно обратится напрямую к файлу (зная путь к нему), нужно хранить информацию о заданиях в конфигурационных файлах JSON.

Часть задачи по поиску нужных файлов можно упростить за счет структуры заданий "по договоренности". 


Ограничения и требования:
* Из библиотек можно использовать только jQuery, и перечисленные в задании.
* Нельзя использовать готовые плагины для табов, но можно и нужно смотреть как устроены уже существующие плагины.

- - -


По умолчанию Chrome не может работать с локальными файлами и получать их в виде AJAX ответов. Поэтому ему нужно поставить соответствующий флаг при вызове исполняемого файла.

Алгоритм (для Chrome и Windows):
1. Создаем ярлык на рабочий стол исполняемого файла chrome.exe.
2. Создаем папку на диске С - "C:/temp-chrome-eng".
3. Кликаем правой кнопкой мыши по ярлыку и в свойствах в поле Объект прописываем:
"C:\Program Files\Google\Chrome\Application\chrome.exe" --disable-web-security --user-data-dir="C:/temp-chrome-eng" 
Первая часть строки  - это где лежит исполняемый файл. Ее менять не нужно. Только добавить флаги.
4. Нажимаем применить.

Теперь запускаем Хром по этому ярлыку. Перетаскиваем на рабочую область Хрома файл index.html c аяксом. Все.

Вот описание данной проблемы в оригинальной статье: http://stackoverflow.com/questions/3102819/chrome-disable-same-origin-policy
Особенное внимание следует обратить на ответы:
1. http://stackoverflow.com/a/18465787
2. http://stackoverflow.com/a/19317888

И всяких генераторов полно http://www.ajaxload.info для крутилок.

В этом цикле в переменную key записывается строка с ключом объекта. При этом с переменной myJSON ничего не происходит. Получается ты обращаешься к свойству объекта Name столько раз, сколько в объекте ключей. Циклы по объектам строятся так:


var people = {
    manya: true,
    valya: true,
    dasha: false,
    petya: false
}

for (var personName in people) {
    console.log(personName, people[personName])
}

Или так:

var people = {
    manya: true,
    valya: true,
    dasha: false,
    petya: false
}

Object.keys(people).forEach(function (personName) {
    console.log(personName, people[personName])
})


И пожалуйста, никаких названий переменных myVariableName. Пиши названия переменных и методов серьезно, как если бы писал проект, а не домашнюю работу по информатике.

> выходит наш один главный модуль будет иниализировать остальные модули по мере их загрузки?

В общем - так. Он (или другой модуль) будет инициализировать подгрузку других модулей, которые будут стрелять событие готовности (на который главный модуль уже подписан (пример - ниже)). И это все в рамках тренировки работы с модулями. Приложение, построенное по такой архитектуре будет легко расширяемым (что в принципе актуально для портфолию новичков).

Один из возможных вариантов - при экспорте модуля стрелять событие о готовности модуля, к которому будет привязываться главный модуль.

// TagList

// ...

window.TagList = TagList

mediator.trigger('module-loaded', 'TagList')

}(jQuery, mediator));




// Main module

// ... 

mediator.subscribe('module-loaded', function (moduleName) {

if (moduleName === 'TagList') {

initTagListDemo()

}

})


mediator.subscribe('module-loaded', function (moduleName) {

if (moduleName === 'Zoomer') {

initZoomerListDemo()

}

})

}(mediator));
-------------------------------

> Например текущий вопрос, что делать в случае если список домашек не поместится на высоту экрана?

Сделать прокрутку. Можно просто через overflow: auto, можно собственную, как тут http://ilyabirman.ru (под плашкой знака равенства)
> но внешний вид наверно будет не особо привлекателен из-за двух скролов на странице.

Кастомовый скролл решит эту проблему. Можно если что, использовать плагин
> А особенно когда маленький список домашек это совсем не к сати, очевидно снова понадобится JS,
> чтобы убрать скролинг для маленького списка. Что лучше?

Держать актуальное количество примеров (не более пяти) с внешней ссылкой на все оставшиеся примеры, когда их домашек наберется прилично.
> Второй вопрос: как правильно растянуть блок с кодом на весь экран? В моем случае, похоже
> наилучший вариант - подставлять JS-ом высоту экрана?

Да, поддерживаю. А можно вообще устроить скроллинг на всю высоту экрана, при этом оставляя табы и левую колонку всегда на виду. 
> Третье: что делать с табиками, если их будет слишком много пока не думал.

горизонтально скроллировать, или ужимать (эти решения есть в браузерах, можно глянуть как выглядит хром или фаерфокс со множественными табами)


